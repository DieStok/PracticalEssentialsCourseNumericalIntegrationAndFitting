# Base R plotting
plot(x~time)
curve(0.1 * exp(x)/(1+0.1*(exp(x)-1.)), add=T)
legend("topleft", c("approximation", "analytical"),
pch=c(1,NA), lty=c(NA,1))
#ggplot plotting
dataFramePlot <- data.frame(x_value = c(x, 0.1 * exp(time)/(1+0.1*(exp(time)-1.))),
time = time,
solution_method = c(rep("Approximation", length(x)), rep("Analytical", length(x)))
)
ggplot2::ggplot(data = dataFramePlot,
aes (x = time, y = x_value, colour = solution_method)) +
geom_point(data = dataFramePlot %>% subset(solution_method == "Approximation"), size = 2) +
geom_line(data = dataFramePlot %>% subset(solution_method != "Approximation"), size = 1.2) +
theme_bw() +
ggtitle(paste0("Approximate versus analytical solution of f(x) = x*(1-x) for time step of ", timestep, "")) +
theme(plot.title = element_text(hjust = 0.5)) +
scale_color_brewer(palette = "Paired")
# time intervals: a sequence from zero to ten at timestep steps
timestep = 0.5
time <- seq(0, 10, by = timestep)
# initial condition
x0 <- 0.1
## The function to be integrated (right-hand expression of the derivative above)
f <- function(x){x * (1.-x)}
## An empty R vector to store the results
x <- c()
## Store the initial condition in the first position of the vector
x[1] <- x0
# loop over time: approximate the function at each time step
#timing for question c
startTime = proc.time()
for (i in 1:(length(time)-1)){
x[i+1] = x[i] + timestep * f(x[i])
}
#timing for question c
calculationTime = proc.time() - startTime
# Base R plotting
plot(x~time)
curve(0.1 * exp(x)/(1+0.1*(exp(x)-1.)), add=T)
legend("topleft", c("approximation", "analytical"),
pch=c(1,NA), lty=c(NA,1))
#ggplot plotting
dataFramePlot <- data.frame(x_value = c(x, 0.1 * exp(time)/(1+0.1*(exp(time)-1.))),
time = time,
solution_method = c(rep("Approximation", length(x)), rep("Analytical", length(x)))
)
ggplot2::ggplot(data = dataFramePlot,
aes (x = time, y = x_value, colour = solution_method)) +
geom_point(data = dataFramePlot %>% subset(solution_method == "Approximation"), size = 2) +
geom_line(data = dataFramePlot %>% subset(solution_method != "Approximation"), size = 1.2) +
theme_bw() +
ggtitle(paste0("Approximate versus analytical solution of f(x) = x*(1-x) for time step of ", timestep, "")) +
theme(plot.title = element_text(hjust = 0.5)) +
scale_color_brewer(palette = "Paired")
#In coding, you should observe DRY, Don't Repeat Yourself. Hence, we put the code into a function that allows us to change the timestep and plot the results. We'll run this with a large and a small time step.
source("HelperFunctionsAnswerFile.R")
####################
##Answer question c:
####################
#for time step is 2
resultLargeStep = runSimpleNumericalIntegration(timeStep = 2, maxTime = 500)
resultLargeStep$timeExpended
resultLargeStep$Totdifferences
#it is clear that the integration is going completely awry here, overshooting and undershooting a lot.
#The summed difference is qite large (~9.65)
#you can see this even better if you only perform a few steps.
resultLargeStepShortInterval = runSimpleNumericalIntegration(timeStep = 2, maxTime = 6)
#If you set the time step to be small things turn out a lot better.
resultSmallStep = runSimpleNumericalIntegration(timeStep = 0.01, maxTime = 500)
resultSmallStep$timeExpended
resultSmallStep$Totdifferences
#Here the integration works fine. The total sum of differences is also much smaller: ~0.34
####################
##Answer question d:
####################
#This is already shown in the code above for answer A. For smaller time steps and longer time spans, execution time increases. It is not a linear relationship, which you would expect. This is because all sorts of things happen under the hood that muddle the direct dependency.
#for more intense timing needs, the package microbenchmark can be used. However, because the calculations here are so quick, execution time is sometimes difficult to measure and that would be overkill in this situation. Good to remember for later though.
#Again, we functionalised the code above so we can easily plot different time steps.
source("HelperFunctionsAnswerFile.R")
#set timestep to 0.01 to see some surprising behaviour:
resultNegative = runEulerBacteriaResource(0.01)
#set timestep to 0.01 to see some surprising behaviour:
resultNegative = runEulerBacteriaResource(0.01)
timeStep
timeStep = 0.5
maxTime = 100
calculationTime = 0.020000024
print(paste0("Calculation time for time step ", timeStep,
" for ", maxTime, " steps total: ", calculationTime
)
)
#######################
#answer question c + d:
#######################
#Again, we functionalised the code above so we can easily plot different time steps.
source("HelperFunctionsAnswerFile.R")
#set timestep to 0.01 to see some surprising behaviour:
resultNegative = runEulerBacteriaResource(timeStep = 0.01, maxTime = 12)
############################
#fun wiggles occur at 0.0075:
############################
resultWiggles = runEulerBacteriaResource(timeStep = 0.0075, maxTime = 12)
#Taken together: values below about 0.0075 should be fine.
#######################
#answer question c + d:
#######################
#Again, we functionalised the code above so we can easily plot different time steps.
source("HelperFunctionsAnswerFile.R")
#set timestep to 0.01 to see some surprising behaviour:
resultNegative = runEulerBacteriaResource(timeStep = 0.01, maxTime = 12)
############################
#fun wiggles occur at 0.0075:
############################
resultWiggles = runEulerBacteriaResource(timeStep = 0.0075, maxTime = 12)
#Taken together: values below about 0.0075 should be fine.
#Again, we functionalised the code above so we can easily plot different time steps.
source("HelperFunctionsAnswerFile.R")
#######################
#answer question c + d:
#######################
#Again, we functionalised the code above so we can easily plot different time steps.
source("HelperFunctionsAnswerFile.R")
#set timestep to 0.01 to see some surprising behaviour:
resultNegative = runEulerBacteriaResource(timeStep = 0.01, maxTime = 12)
############################
#fun wiggles occur at 0.0075:
############################
resultWiggles = runEulerBacteriaResource(timeStep = 0.0075, maxTime = 12)
#Taken together: values below about 0.0075 should be fine.
############################
#fun wiggles occur at 0.0075:
############################
resultWiggles = runEulerBacteriaResource(timeStep = 0.0075, maxTime = 12, plotType = "line")
#######################
#answer question c + d:
#######################
#Again, we functionalised the code above so we can easily plot different time steps.
source("HelperFunctionsAnswerFile.R")
#set timestep to 0.01 to see some surprising behaviour:
resultNegative = runEulerBacteriaResource(timeStep = 0.01, maxTime = 12)
############################
#fun wiggles occur at 0.0075:
############################
resultWiggles = runEulerBacteriaResource(timeStep = 0.0075, maxTime = 12, plotType = "line")
#Taken together: values below about 0.0075 should be fine.
#setup, loading deSolve
if(!require(pacman)) {
install.packages("pacman"); require(pacman)}
p_load(tidyverse, cowplot, deSolve)
#this format is acceptable for deSolve (and Grind). We will explain how this model definition works in more detail in the next question
model <- function(t, state, parms) {
# state <- ifelse(state<0,0,state)
with(as.list(c(state,parms)), {
f <- v*R/(k+R)
dtR <- - f*e*B
dtB <- f*B
return(list(c(dtR, dtB)))
})
}
# Parameters
p <- c(e=5e-7,v=1.4,k=1)
# Initial conditions
# Note: This HAS to be in the order in which you define the equations in the list of functions returned by model.
# So same order as dtR and dtB
s <- c(R=350,B=1e3)
# Time vector
timestep <- 0.5
time <- seq(0,12,by=timestep)
# Solve the system using the Euler method
startTiming = proc.time()
out <- ode(y=s, times=time, func=model, parms=p, method="euler", hini=timestep)
out_euler <- data.frame(out)
timeEuler = proc.time() - startTiming
# Solve the system using Runge-Kutta 23, with dynamical time step
startTiming = proc.time()
out <- ode(y=s, times=time, func=model, parms=p, method="ode23", hini=timestep)
out_rk23 <- data.frame(out)
timeRKMethod = proc.time() - startTiming
# Plot results base R
dev.off()
# Plot results base R
par(mfrow=c(2,1))
plot(time,out_euler$R, type='l', col='red', lwd=3)
lines(time,out_rk23$R, type='l', col='orange', lwd=3)
plot(time,out_euler$B, type='l', col='blue', lwd=3, log="y")  # Note: logarithmic y-axis
lines(time, out_rk23$B, type='l', col='cyan', lwd=3)
#Plot results ggplot --> arranged with cowplot library (see here: https://wilkelab.org/cowplot/index.html)
dataFramePlotsEulerVsRK = dplyr::bind_rows(out_euler, out_rk23) %>%
mutate(method = c(rep("Euler", nrow(out_euler)),
rep("Runge-Kutta23", nrow(out_rk23)))
)
Rplot = dataFramePlotsEulerVsRK %>%
ggplot(aes(x = time, y = R, colour = method)) +
geom_point() +
theme_bw() +
# we set the left and right margins to 0 to remove
# unnecessary spacing in the final plot arrangement.
theme(plot.margin = margin(6, 0, 6, 0))
Bplot = dataFramePlotsEulerVsRK %>%
ggplot(aes(x = time, y = B, colour = method)) +
geom_point() +
theme_bw() +
scale_y_continuous(trans = "log",
breaks = c(2, 20, 200, 2000, 20000, 200000, 2000000, 20000000, 200000000, 2000000000)
) +
theme(plot.margin = margin(6, 0, 6, 0))
legend = get_legend(
# create some space to the left of the legend
Rplot + theme(legend.box.margin = margin(0, 0, 0, 12))
)
rowPlots = cowplot::plot_grid(Rplot + theme(legend.position = "none"),
Bplot + theme(legend.position = "none"),
labels = c("A", "B"),
align = "vh",
hjust = -1,
nrow = 2)
plot_grid(rowPlots, legend, rel_widths = c(3, 1))
#what about calculation time?
print(paste0("Calculation Euler for timestep: ", timestep))
print(timeEuler)
print(paste0("Calculation Runge-Kutta23 for timestep: ", timestep))
print(timeRKMethod)
#loading required packages and sourcing Grind
if(!require(pacman)) {
install.packages("pacman"); require(pacman)}
p_load(tidyverse, rootSolve, deSolve, FME)
source("grind.R")
fig3RA <- readr::read_csv("Fig3/2015-11-18_R.csv")
fig3RA =  fig3RA %>% dplyr::rename(Identifier = ...1)
head(fig3RA)
fig3RA <- readr::read_csv("Fig3/2015-11-18_R.csv") %>% dplyr::rename(Identifier = ...1)
head(fig3RA)
head(fig3RA)
model <- function(t, state, parms) {
with(as.list(c(state,parms)), {
a <- q0/(q0+exp(-m*t))
dN <- r*a*N*(1-(N/K)^v)
return(list(dN))
})
}
parametersForFitting = c(v = 1.22, r = 1.05, q0 = 0.0023, m = 2, K = 0.6)
print(names(parametersForFitting))
names(parametersForFitting)[1] = "suchChangeMuchW0W"
print(names(parametersForFitting))
#let's change it back. No Venetian nobles allowed on my watch!
names(parametersForFitting)[1] = "v"
#First, normal numerical integration without any fitting. These are nonsense parameters!
#We need a starting amount of bacteria
initialState         = c(N = 0.124) #units are OD.
parametersForFitting = c(v = 1.22, r = 1.05, q0 = 0.0023, m = 2, K = 0.6)
#numerically integrate the model, from time 1 to 100
#use as the initial values (the state vector) initialState
#find the parameters in the named vector parametersForFitting
#the equation for the ODE/calculations we want to do are in the function called model
run(tmax = 100, tstep = 1,
state = initialState,
parms = parametersForFitting,
odes = model
)
#still plots, can make it not do that by adding timeplot = FALSE to the run command call.
grindResultsTimeCourse = run(tmax = 100, tstep = 1,
state = initialState,
parms = parametersForFitting,
odes = model, table = TRUE, draw = points
)
print(head(grindResultsTimeCourse))
ggplot(grindResultsTimeCourse, aes(x= time, y = N)) +
geom_point(colour = "red") +
theme_bw()
#we make a character vector of all the variables we want Grind to fit. Here, that's N and all the parameters.
free <- c("N",names(parametersForFitting))
#for the lower bound, we bound everything at 0, and v at 1. A decelaration parameter that becomes lower than 1 would accelerate given the formula, so that would be strange
lower <- rep(0, length(free)); lower[match("v",free)] <- 1; lower  # set lower bounds
#to fit, Grind wants a data frame with time and the variables it needs to fit. Note how we rename OD to N to be consistent.
data3RA <- as.data.frame(cbind(fig3RA$Time,fig3RA$OD)); names(data3RA) <- c("time","N")
#now we fit the parameters. fun = log tells the fitting that we want to fit the log of the data, not the actual data. The other parameters are self-explanatory. Note that we also start from some initial parameter values and improve the fit from there. For now, we'll just use the parameters from above.
fit3RA  <- fit(data3RA, state = initialState, odes = model, parms = parametersForFitting,
free=free,fun=log,lower=lower,pch=".",
legend=FALSE,tstep=0.1,main="Fig 3 a red monoculture (fun=log)",
ymin = 0, ymax = 1
)
summary(fit3RA)
model <- function(t, state, parms) {
with(as.list(c(state,parms)), {
a <- q0/(q0+exp(-m*t))
dN <- r*a*N*(1-(N/K)^v)
return(list(dN))
})
}
parametersForFitting = c(K=0.6,r=0.4,m=2,q0=0.005,v=2)
print(names(parametersForFitting))
names(parametersForFitting)[1] = "suchChangeMuchW0W"
print(names(parametersForFitting))
#let's change it back. No Venetian nobles allowed on my watch!
names(parametersForFitting)[1] = "v"
#First, normal numerical integration without any fitting. These are nonsense parameters!
#We need a starting amount of bacteria
initialState         = c(N = 0.124) #units are OD.
parametersForFitting = c(v = 1.22, r = 1.05, q0 = 0.0023, m = 2, K = 0.6)
#numerically integrate the model, from time 1 to 100
#use as the initial values (the state vector) initialState
#find the parameters in the named vector parametersForFitting
#the equation for the ODE/calculations we want to do are in the function called model
run(tmax = 100, tstep = 1,
state = initialState,
parms = parametersForFitting,
odes = model
)
#still plots, can make it not do that by adding timeplot = FALSE to the run command call.
#draw = points gives scatter plot rather than line plot
grindResultsTimeCourse = run(tmax = 100, tstep = 1,
state = initialState,
parms = parametersForFitting,
odes = model, table = TRUE, draw = points
)
print(head(grindResultsTimeCourse))
ggplot(grindResultsTimeCourse, aes(x= time, y = N)) +
geom_point(colour = "red") +
theme_bw()
#we make a character vector of all the variables we want Grind to fit. Here, that's N and all the parameters.
free <- c("N",names(parametersForFitting))
#for the lower bound, we bound everything at 0, and v at 1. A decelaration parameter that becomes lower than 1 would accelerate given the formula, so that would be strange
lower <- rep(0, length(free)); lower[match("v",free)] <- 1; lower  # set lower bounds
#to fit, Grind wants a data frame with time and the variables it needs to fit. Note how we rename OD to N to be consistent.
data3RA <- as.data.frame(cbind(fig3RA$Time,fig3RA$OD)); names(data3RA) <- c("time","N")
#now we fit the parameters. fun = log tells the fitting that we want to fit the log of the data, not the actual data. The other parameters are self-explanatory. Note that we also start from some initial parameter values and improve the fit from there. For now, we'll just use the parameters from above.
fit3RAlog  <- fit(data3RA, state = initialState, odes = model, parms = parametersForFitting,
free=free, fun=log, lower=lower, pch=".",
legend=FALSE, tstep=0.1, main="Fig 3 a red monoculture (fun=log)",
ymin = 0, ymax = 1
)
summary(fit3RAlog)
fit3RA     <- fit(data3RA, state = initialState, odes = model, parms = parametersForFitting,
free=free, lower=lower, pch=".",
legend=FALSE, tstep=0.1, main="Fig 3 a red monoculture (fun=log)",
ymin = 0, ymax = 1
)
summary(fit3RA)
#we make a character vector of all the variables we want Grind to fit. Here, that's N and all the parameters.
free <- c("N",names(parametersForFitting))
#for the lower bound, we bound everything at 0, and v at 1. A decelaration parameter that becomes lower than 1 would accelerate given the formula, so that would be strange
lower <- rep(0, length(free)); lower[match("v",free)] <- 1; lower  # set lower bounds
#to fit, Grind wants a data frame with time and the variables it needs to fit. Note how we rename OD to N to be consistent.
data3RA <- as.data.frame(cbind(fig3RA$Time,fig3RA$OD)); names(data3RA) <- c("time","N")
#now we fit the parameters. fun = log tells the fitting that we want to fit the log of the data, not the actual data. The other parameters are self-explanatory. Note that we also start from some initial parameter values and improve the fit from there. For now, we'll just use the parameters from above.
fit3RAlog  <- fit(data3RA, state = initialState, odes = model, parms = parametersForFitting,
free=free, fun=log, lower=lower, pch=".",
legend=FALSE, tstep=0.1, main="Fig 3 a red monoculture (fun=log)",
ymin = 0, ymax = 1
)
summary(fit3RAlog)
fit3RA     <- fit(data3RA, state = initialState, odes = model, parms = parametersForFitting,
free=free, lower=lower, pch=".",
legend=FALSE, tstep=0.1, main="Fig 3 a red monoculture",
ymin = 0, ymax = 1
)
summary(fit3RA)
source("../HelperFunctionsAnswerFile.R")
dataAndFitsFigureThree = readInDataFigureThreeRamPaper()
source("../HelperFunctionsAnswerFile.R")
dataAndFitsFigureThree = readInDataFigureThreeRamPaper()
source("../HelperFunctionsAnswerFile.R")
dataAndFitsFigureThree = readInDataFigureThreeRamPaper()
#I do this so I can easily calculate fits using Fig4A, and fig3A data later on, same for B, C.
expSeq = c(exptA, exptB, exptC)
names(expSeq) = c("exptA", "exptB", "exptC")
listFitsFigure3 <- list()
for (exp in seq_along(expSeq)) {
dataFig3RLoop = read.csv(paste("Fig3/",expSeq[exp],"_R.csv",sep="")) # Red
dataFig3GLoop = read.csv(paste("Fig3/",expSeq[exp],"_G.csv",sep="")) # Green
sLoop <- c(N=0.124)
pLoop <- c(K=0.6,r=0.4,m=2,q0=0.005,v=2)
freeLoop <- c("N",names(pLoop))
lowerLoop <- rep(0, length(freeLoop))
lowerLoop[match("v",freeLoop)] <- 1 # set lower bounds
#Red data and fit
dataFig3RLoop <- as.data.frame(cbind(dataFig3RLoop$Time,dataFig3RLoop$OD))
names(dataFig3RLoop) <- c("time","N")
print(paste0("Fitting figure 3 data for the red bacteria for: ", names(expSeq[exp])))
fitFig3RLoop <- fit(dataFig3RLoop,free=freeLoop,fun=log,lower=lowerLoop,
pch=".",legend=FALSE,tstep=0.1,main=paste0("Fig 3 Red for ",names(expSeq[exp])),
ymin = 0, ymax = 1)
#Green data and fit
dataFig3GLoop <- as.data.frame(cbind(dataFig3GLoop$Time,dataFig3GLoop$OD))
names(dataFig3GLoop) <- c("time","N")
print(paste0("Fitting figure 3 data for the green bacteria for: ", names(expSeq[exp])))
fitFig3GLoop <- fit(dataFig3GLoop,free=freeLoop,fun=log,lower=lowerLoop,
pch=".",legend=FALSE,tstep=0.1,main=paste0("Fig 3 Green for ",names(expSeq[exp])),
ymin = 0, ymax = 1)
#add to list under correct name
listFitsFigure3[[paste0("Data", names(expSeq)[exp], "Fig3G")]] <- dataFig3GLoop
listFitsFigure3[[paste0("Data", names(expSeq)[exp], "Fig3R")]] <- dataFig3RLoop
listFitsFigure3[[paste0("Fit", names(expSeq)[exp], "Fig3G")]]  <- fitFig3GLoop
listFitsFigure3[[paste0("Fit", names(expSeq)[exp], "Fig3R")]]  <- fitFig3RLoop
}
# The 3 experiments are indexed by their date:
exptA <- "2015-11-18"  #Experiment A
exptB <- "2015-12-14"  #Experiment B
exptC <- "2016-01-06"  #Experiment C
# First read and plot all data (for exptA):
fig3RA <- read.csv(paste("Fig3/",exptA,"_R.csv",sep="")) # Red
fig3GA <- read.csv(paste("Fig3/",exptA,"_G.csv",sep="")) # Green
plot(fig3RA$Time, fig3RA$OD, ylim=c(0,0.8),col="red",pch=".",xlab="Time (hr)",ylab="OD")
points(fig3GA$Time, fig3GA$OD, ylim=c(0,0.8),col="green",pch=".")
fig4 <- read.csv(paste("Fig4/",exptA,"_RG.csv",sep=""))
plot(fig4$Time, fig4$OD, ylim=c(0,0.8), col="blue", pch=".", xlab="Time (hr)", ylab="Total OD")
fig5 <- read.csv(paste("Fig5/flow_df_",exptA,".csv",sep=""))
fig5G <- fig5[fig5$Strain=="Green",]
fig5R <- fig5[fig5$Strain=="Red",]
plot(fig5G$time, fig5G$freq_mean, ylim=c(0,1), col="green",xlab="Time (hr)", ylab="Frequency")
points(fig5R$time, fig5R$freq_mean, col="red")
# Here the fitting starts
model <- function(t, state, parms) {
with(as.list(c(state,parms)), {
a <- q0/(q0+exp(-m*t))
dN <- r*a*N*(1-(N/K)^v)
return(list(dN))
})
}
#I do this so I can easily calculate fits using Fig4A, and fig3A data later on, same for B, C.
expSeq = c(exptA, exptB, exptC)
names(expSeq) = c("exptA", "exptB", "exptC")
listFitsFigure3 <- list()
for (exp in seq_along(expSeq)) {
dataFig3RLoop = read.csv(paste("Fig3/",expSeq[exp],"_R.csv",sep="")) # Red
dataFig3GLoop = read.csv(paste("Fig3/",expSeq[exp],"_G.csv",sep="")) # Green
sLoop <- c(N=0.124)
pLoop <- c(K=0.6,r=0.4,m=2,q0=0.005,v=2)
freeLoop <- c("N",names(pLoop))
lowerLoop <- rep(0, length(freeLoop))
lowerLoop[match("v",freeLoop)] <- 1 # set lower bounds
#Red data and fit
dataFig3RLoop <- as.data.frame(cbind(dataFig3RLoop$Time,dataFig3RLoop$OD))
names(dataFig3RLoop) <- c("time","N")
print(paste0("Fitting figure 3 data for the red bacteria for: ", names(expSeq[exp])))
fitFig3RLoop <- fit(dataFig3RLoop,free=freeLoop,fun=log,lower=lowerLoop,
pch=".",legend=FALSE,tstep=0.1,main=paste0("Fig 3 Red for ",names(expSeq[exp])),
ymin = 0, ymax = 1)
#Green data and fit
dataFig3GLoop <- as.data.frame(cbind(dataFig3GLoop$Time,dataFig3GLoop$OD))
names(dataFig3GLoop) <- c("time","N")
print(paste0("Fitting figure 3 data for the green bacteria for: ", names(expSeq[exp])))
fitFig3GLoop <- fit(dataFig3GLoop,free=freeLoop,fun=log,lower=lowerLoop,
pch=".",legend=FALSE,tstep=0.1,main=paste0("Fig 3 Green for ",names(expSeq[exp])),
ymin = 0, ymax = 1)
#add to list under correct name
listFitsFigure3[[paste0("Data", names(expSeq)[exp], "Fig3G")]] <- dataFig3GLoop
listFitsFigure3[[paste0("Data", names(expSeq)[exp], "Fig3R")]] <- dataFig3RLoop
listFitsFigure3[[paste0("Fit", names(expSeq)[exp], "Fig3G")]]  <- fitFig3GLoop
listFitsFigure3[[paste0("Fit", names(expSeq)[exp], "Fig3R")]]  <- fitFig3RLoop
}
?index
??index
source("../HelperFunctionsAnswerFile.R")
dataAndFitsFigureThree = readInDataFigureThreeRamPaper()
source("../HelperFunctionsAnswerFile.R")
dataAndFitsFigureThree = readInDataFigureThreeRamPaper()
source("../HelperFunctionsAnswerFile.R")
dataAndFitsFigureThree = readInDataFigureThreeRamPaper()
?plot
source("../HelperFunctionsAnswerFile.R")
dataAndFitsFigureThree = readInDataFigureThreeRamPaper()
source("../HelperFunctionsAnswerFile.R")
dataAndFitsFigureThree = readInDataFigureThreeRamPaper()
source("../HelperFunctionsAnswerFile.R")
dataAndFitsFigureThree = readInDataFigureThreeRamPaper()
#you can access the data and fits using either $ or [[]]:
head(dataAndFitsFigureThree$DataexptAFig3G)
head(dataAndFitsFigureThree[["DataexptAFig3R"]])
#use
dataAndFitsFigureThree$DataexptBFig3R
#use
dataAndFitsFigureThree$FitexptBFig3G
#query the fits in the list above (using summary(fitObject))
summary(dataAndFitsFigureThree$FitexptBFig3R)
#query the fits in the list above (using summary(fitObject))
dataAndFitsFigureThree$FitexptBFig3R
#we make a character vector of all the variables we want Grind to fit. Here, that's N and all the parameters.
free <- c("N",names(parametersForFitting))
#for the lower bound, we bound everything at 0, and v at 1. A decelaration parameter that becomes lower than 1 would accelerate given the formula, so that would be strange
lower <- rep(0, length(free)); lower[match("v",free)] <- 1; lower  # set lower bounds
#to fit, Grind wants a data frame with time and the variables it needs to fit. Note how we rename OD to N to be consistent.
data3RA <- as.data.frame(cbind(fig3RA$Time,fig3RA$OD)); names(data3RA) <- c("time","N")
#now we fit the parameters. fun = log tells the fitting that we want to fit the log of the data, not the actual data. The other parameters are self-explanatory. Note that we also start from some initial parameter values and improve the fit from there. For now, we'll just use the parameters from above.
fit3RAlog  <- fit(data3RA, state = initialState, odes = model, parms = parametersForFitting,
free=free, fun=log, lower=lower, pch=".",
legend=FALSE, tstep=0.1, main="Fig 3 a red monoculture (fun=log)",
ymin = 0, ymax = 1
)
summary(fit3RAlog)
fit3RA     <- fit(data3RA, state = initialState, odes = model, parms = parametersForFitting,
free=free, lower=lower, pch=".",
legend=FALSE, tstep=0.1, main="Fig 3 a red monoculture",
ymin = 0, ymax = 1
)
summary(fit3RA)
#in this fit, you can get at the fitted parameters using $par
print(fit3RA$par)
#query the fits in the list above. You can just print them (especially their $par component that holds the fitted parameters), or print their summary()
#answer:
dataAndFitsFigureThree$FitexptBFig3R
dataAndFitsFigureThree$FitexptBFig3R$par
summary(dataAndFitsFigureThree$FitexptBFig3R)
#query the fits in the list above. You can just print them (especially their $par component that holds the fitted parameters), or print their summary()
#answer:
print("You can read the parameters from the print-out of the full list:")
dataAndFitsFigureThree$FitexptBFig3R
print("Or just look at the parameters:")
dataAndFitsFigureThree$FitexptBFig3R$par
print("Or look at the summary, which gives a lot of warnings about the fitting of all these parameters not going well! :")
summary(dataAndFitsFigureThree$FitexptBFig3R)
